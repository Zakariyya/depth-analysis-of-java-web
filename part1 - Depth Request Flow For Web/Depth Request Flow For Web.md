# 深入Web请求过程

[TOC]



## B/S网络架构概述

**B/S**网络架构从前端到后端都得到了简化，都基于同一的应用层协议HTTP来交互数据，与大多数传统**C/S**互联网应用程序采用的长连接的交互模式不同，HTTP采用无状态的短链接的通讯方式，通常情况下，一次请求就完成了一次数据交互，通常也对应一个业务逻辑，然后这次通讯连接就会断开了。采用这种方式是为了能同时服务更多的用户，因为当前互联网应用每天都会处理上亿的用户请求，不可能每个用户访问一次后就一直保持这个连接。

不管网络架构如何变化，始终有一些固定不变的原则需要遵守。

- 互联网上所有资源都要用一个URL来表示。URL就是统一资源定位符，如果你要发布一个服务或者一个资源到互联网上，让别人能够访问到，那么你首先必须要有一个世界上独一无二的URL。不要小看这个URL，它几乎包含了整个互联网架构的精髓。
- 必须基于HTTP与服务端交互。不管你要访问的是国内的还是国外的数据，是文本数据还是流媒体，都必须按照套路出牌，也就是都得采用统一打招呼的方式，这样人家才会明白你要的是什么。
- 数据展示必须在浏览器中进行。当你获取到数据资源后，必须在浏览器上才能恢复它的容貌。

只要满足上面几点，一个互联网应用基本上就能正确地运转起来了，当然这里面还有好多细节，这些细节在后面将分别进行详细讲解。

## 如何发起一个请求

如何发起一个HTTP请求和如何建立一个**Socket**连接区别不大，只不过**outputStream.write** 写的二进制字节数据格式要符合HTTP。浏览器在建立Socket连接之前，必须根据地址栏里输入URL的域名DNS解析出IP地址，再根据这个IP地址和默认的80端口与远程服务器建立Socket连接，然后浏览器根据这个**URL**组装成一个get类型的HTTP请求头通过**outputStream**.**write**发送到目标服务器，服务器等待i**nputStream.read** 返回数据，最后断开这个连接。

当然，不同浏览器在如何使用这个已经建立好的连接以及根据什么规则来管理连接上，有各种不同的实现方法。一句话，发起一个**HTTP**请求的过程就是建立**Socket**通信的过程。

既然发起一个**HTTP**连接本质就是建立一个**Socket**连接，那么我们完全可以模拟浏览器来发起HTTP请求，这很好实现，也有很多方法实现，如**HttpClient**就是一个开源的通过程序实现的处理**HTTP**请求的工具包。当然如果你对HTTP的数据结构非常熟悉，你完全可以自己再实现另外一个**HttpClient**，甚至可以自己写个简单的浏览器。

下面是基本的**HttpClient**的调用示例：

~~~java
HttpClient httpClient = createHttpClient();
PostMethod postMethod;
String domainName = Switcher.domain;
postMethod = new PostMethod(domainName);
postMethod.addRequestHeader("Content-Type","application/x-www-from-urlencoded; charset=GBK");
for(FilterData filterData:filterDatas){
    postMethod.addParameter("ip",filterData.ip);
    postMethod.addParameter("count",String.valueOf(filterData.count));
}
try{
    httpClient.executeMethod(postMethod);
    postMethod.getResponseBodyAsString();
}catch(Exception e){
    logger.error(e);
}
~~~

处理Java中使用非常普遍的HttpClient还有很多类似的工具，如linux中的curl命令，通过curl+URL 就可以简单地发起HTTP请求，非常方便。

## HTTP解析

**B/S**网络结构的核心是HTTP，掌握HTTP对一个从事互联网的程序员来说是非常重要的，也许你已经非常熟悉HTTP。

要理解HTTP，最重要的就是熟悉HTTP中**HTTP Header**，HTTP Header控制这互联网上成千上万的用户的数据的传输。关键的是，它控制着用户浏览器的渲染行为和服务器的执行逻辑。例如，当服务器没有用户请求的数据时就会返回一个**404**状态码，告知浏览器没有请求的数据，通常浏览器会展示一个非常不愿意看到的“**该页面不存在**”的错误信息。

常见的HTTP请求头和响应头分别如表1、2。

常见的额HTTP状态码如表3

常见的HTTP请求头

| 请求头             | 说明                                       |
| --------------- | ---------------------------------------- |
| Accept-Charset  | 用于指定客户端接收的字符集                            |
| Accept-Encoding | 用于指定可接受的内容编码，如Accept-Encoding:gzip.deflate |
| Accept-language | 用于指定一种自然语言，如Accept-language:zh-cn        |
| Host            | 用于指定被请求资源的Internet主机和端口号，如Host:www.taobao.com |
| User-Agent      | 客户端将它的操作系统，浏览器和其他属性告诉服务器                 |
| Connextion      | 当前连接是否保持，如Connetion:Keep-Alive           |

常见的HTTP响应头

| 响应头              | 说明                                       |
| ---------------- | ---------------------------------------- |
| Server           | 使用服务器名称，如Server:Apache/1.3.6(Unix)       |
| Content-Type     | 用来指明发送给接收者的实体正文的媒体类型，如Content-Type:text/html;charset=GBK |
| Content-Encoding | 与请求包头Accept-Encoding对应，告诉浏览器服务端采用的是什么压缩编码 |
| Content-language | 描述了资源所用的自然语言。与Accept-language对应          |
| Content-length   | 指明实体正文的长度，用以字节方式储存的十进制数字来表示              |
| Keep-Alive       | 保持连接的时间，如keep-Alive:timeout=5,max=120    |

常见的HTTP状态码

| 状态码  | 说明                     |
| ---- | ---------------------- |
| 200  | 客户端请求成功                |
| 302  | 临时跳转，跳转的地址通过location指定 |
| 400  | 客户端请求有语法错误，不能被服务器识别    |
| 403  | 服务器收到请求，但是拒绝提供服务       |
| 404  | 请求的资源不存在               |
| 500  | 服务器发生不可预期的错误           |

***

### 查看HTTP信息的工具

chrome：F12

firefox/IE:懒得看了，不用这两玩意

***

### 浏览器缓存机制

浏览器缓存是一个比较复杂但又是比较重要的机制，在我们浏览一个页面时发现有一场的情况下，通常考虑的就是是不是浏览器做了缓存，所以一般的做法是按Ctrl+F5 重新请求一次这个页面，重新请求的页面肯定是最新的页面。

> 首先在浏览器，如果是按ctrl+F5刷新页面，浏览器会直接项目标URL发送请求，而不会使用浏览器缓存的数据；
>
> 其次，即使请求发生到服务端，也有可能访问的是缓存数据，比如，在我们的应用服务器的前端部署一个缓存服务器，如[Varnish](https://zh.wikipedia.org/wiki/Varnish_cache)代理，那么Varnish也有可能直接使用缓存数据

所以为了保证用户能够看到最新的数据，必须通过HTTP来控制。

当我们使用ctrl+F5刷新一个页面时，在HTTP的请求头会增加一些请求头，它告诉服务器我们要获取最新的数据而不是缓存。

> 尝试这查看下普通刷新和ctrl+F5之后返回的请求头

**最重要的是在其请求头中增加了两个请求项 Pragma:no-cache 和 Cache-Control:no-cache。**

1.  **Cache-Control/Pragma:no-cache**

这个HTTP Head 字段用于指定所有缓存机制在整个请求/相应链中必须服从的指令，如果知道该页面是否为缓存，不仅可以控制浏览器，还可以控制和HTTP相关的缓存或代理服务器。HTTP Head字段有一些可选值，这些值说明表如下

| 可选值                                  | 说明                                       |
| ------------------------------------ | ---------------------------------------- |
| Public                               | 所有内容都将被缓存，在响应头中设置                        |
| Private                              | 内容只缓存到私有缓存中，在响应头中设置                      |
| no-cache                             | 所有内容都不会被缓存，在请求头和响应头中设置                   |
| no-store                             | 所有内容都不会被缓存到缓存或Internet临时文件中，在响应头中设置      |
| must-revalidation/proxy-revalidation | 如果缓存的内容失败，请求必须发送到服务器/代理服务器以进行重新验证，在请求头中设置 |
| max-age=xxx                          | 缓存的内容将在xxx秒后失效，这个选项只在HTTP1.1中可用，和Last-Modified一起使用时优先级较高，在响应头中设置 |

Cache-Control请求字段被各个浏览器支持得较好，而且它的优先级较高，它和其他一些请求字段（eg; Expires）同时出现时，Cache-Control 会覆盖其他字段。

Pragma字段的作用和 Cache-Control有点类似，它也是在HTTP头中包含一个特殊的指令，使相关的服务器的遵守该指令，最常用的就是Pragma:no-cache，它和Cache-Control:no-cache的作用是一样的。

2. **Expires**

Expires通常的使用格式是Expires:Sat,25 Feb 2012 12:22:17 GMT  ，后面跟着一个日期和时间，超过这个时间值后，缓存的内容将会失效，也就是浏览器在发出请求之前检查这个页面的这个字段，看该页面是否已经过期，过期了就重新向服务器发起请求。

3. **Last-Modified/Etag**

Last-Modified/Etag 字段一般用于表示一个服务器上的资源的最后修改时间，资源可以是静态（静态内容加上Last-Modified 字段）或者动态的内容（如Servlet提供了一个getLast-Modified方法用于检查某个动态内容是否已经更新），通过这个最后修改时间可以判断当前请求的资源是否是最新的。

一般服务端在响应头中返回一个Last-Modified字段，告诉浏览器这个页面的最后修改时间，如Last-Modified:Sat,25 Feb 2012 12:55:04 GMT ，浏览器再次请求时在请求头中增加一个If-modified-Since:Sat,25 Feb 2012 12:55:04 GMT 字段，询问当前缓存的页面是否是最新的，如果是最新的就返回**304**状态码，告诉浏览器是最新的，服务器也不会传输新的数据。

与Last-Modified字段类似的功能还有一个**Etag**字段，这个字段的作用是让服务端给每个页面分配一个唯一的编号，然后通过这个编号来区分当前这个页面是否是最新的。这种方式比使用Last-Modified更加灵活，但是在后端的web服务器有多台时，比较难处理，因为每个web服务器都要记住网站的所有资源，否则浏览器返回的这个编号就没有意义了。

##DNS域名解析

互联网都是通过URL来发布和请求资源的。而URL中的域名需要解析成IP地址才能与远程主机建立连接，如何将域名解析成IP地址就属于DNS解析的工作范畴

目前世界上的整个互联网有几个DNS根域名服务器，任何一台根服务器坏掉，后果都会非常严重

### DNS域名解析过程

当用户在浏览器中输入www.taobao.com时候，DNS解析将会有将近10个步骤

1. 当用户在浏览器中输入域名并按下回车键后，浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存时间也有限制，通常情况下为几分钟到几小时不等，域名被缓存的时间限制可以通过TTL属性来设置。这个缓存时间太长或太短都不合适

   如果太长，一旦域名被解析到IP有所变化，会导致被客户端缓存的域名无法解析到变化后的IP地址，以致于该域名不能正常解析，这段时间内有可能会有一部分用户无法访问网站。

   如果太短，会导致用户每次访问网站都要重新解析一次域名

2. 如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果。其实操作系统也有一个域名解析过程，可以通过**hosts**文件来设置，可以将任何域名解析到任何能够访问的IP地址。如果你在这里指定了一个域名对应的IP地址，那么浏览器会首先使用这个IP地址。

   例如，在测试时可以将一个域名解析到一台测试服务器上，这样不用修改任何代码就能测试到单独服务器上的代码的业务逻辑是否正确。正式因为这种本地DNS解析的规程，所有黑客就有可能通过修改你的域名来把特定的域名解析到它指定的IP地址上，导致这些域名被劫持

3. 如何、怎么知道域名服务器？

   在网络配置中都会有“**DNS服务器地址**”这一项，这个地址就用于解决前面所说的如果两个过程无法解析时要怎么办，操作系统会把这个域名发送给这里设置的LDNS，也就是本地区的域名服务器。这个DNS通常都提供给你本地互联网接入的一个DNS解析服务，例如你是在学校接入互联网，那么你的DNS服务器肯定在你的学校，你是在一个小区接入互联网的，那么这个DNS就是提供给你互联网的应用提供商，既电信或者联通，也就是通常所说的SPA。那么这个DNS通常也会在你所在城市的某个角落，通常不会很远

4. 如果LDNS仍然没有命中，就直接到Root Server 域名服务器请求解析

5. 根域名服务器返回给本地域名服务器一个所查询的主域名服务器（GTLDServer）地址。gTLD是国际顶级域名服务器，如.com ,  .cn  , .org等等

6. 本地域名服务器（Local DNS Server）再向上一步返回的gTLD服务器发送请求。

7. 接受请求的gTLD服务器查找并返回次域名对应的Name Server域名服务器的地址，这个**Name Server**通常就是你注册的域名服务器，例如你再某个域名服务器提供商申请的域名，那么这个域名解析任务就由这个域名提供商的服务器来完成。

8. **Name Server**域名服务器会查询储存的域名和IP的映射关系表，在正常情况下，都根据域名得到目标IP记录，连同一个TTL值返回给DNSServer域名服务器。

9. 返回该域名对应的IP和TTL值，Local DNS Server 会缓存这个域名和IP的对应关系，缓存时间由TTL控制

10. 把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束

在实际的DNS解析过程中，可能还不止这10个步骤，如Name Server 可能有多级，或者有一个GTM来负载均衡控制，这都有可能会影响域名解析的过程

### 跟踪域名解析过程

略

### 清楚缓存的域名

略

### 几种域名的解析方式

略

## CDN工作机制

CDN 也就是内容分布网络（Content Delivery NetWork），它是构筑在现有Internet上的一种现金的流量分配网络。其目的是通过现有的Internet中增加一层新的网络架构，将网站的内容发不到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的相应速度。有别于镜像，它比镜像更智能，可以做这样的比喻：

> CDN = 镜像（Mirror）+ 缓存（cahce）+ 整体负载均衡（GSLB）

因而CDN可以明显提高Internet中信息流动的效率



目前CDN都以缓存网站中的静态数据为主，如CSS、js、图片和静态页面等数据。用户在从主站服务器请求道动态内容后，在从CDN上下载这些静态数据，从而加速网页数据内容的下载速度，如淘宝由90%以上的数据都是由CDN来提供的。

通常来说CDN要达到一下几个目标

- 可扩展。性能可扩展性：应对新增的大量数据、用户和事务的扩展能力。成本可扩展性：用低廉的运营成本提供动态的服务能力和高质量的内容分发
- 安全性。强调提供物理设备、网络、软件、数据、和服务过程的安全性，（趋势）减少因为DDOS攻击或者其他恶意行为造成商业网站的业务中断
- 可靠性、响应和执行（Reliability、Responsiveness 和 Performance）。服务可用性指能够处理可能的故障和用户体验下降的问题，通过负载均衡即使提供网络的容错机制

###CDN架构

一个用户访问某个静态文件（如CSS文件），这个静态文件的域名假如是cdn.taobao.com，那么首页要向Local DNS 服务器发起请求，一般经过迭代解析后回到这个域名的注册服务器去解析，一般每个公司都会有一个DNS解析服务器。这时这个DNS解析服务器通常会把它重新CNAME解析到另外一个域名，而这个域名最终会被指向CDN全局中的DNS负载均衡服务器，再由这个GTM来最终分配是哪个地方的访问用户，返回给离这个访问用户最近的CDN节点

拿到DNS解析结果，用户就直接去这个CDN节点访问这个静态文件了，如果这个节点中所请求的文件不存在，就会再回到源站去获取这个文件，然后再返回给用户。

### 负载均衡

负载均衡（Load Balance）就是对工作任务进行平衡、分摊到多个操作单元上执行，如图片服务器、应用服务器等，共同完成工作任务。他可以提高服务器响应速度以及利用效率，避免软件或者硬件模块出现单点失效，解决网络拥塞问题，实现地理位置无关性，为用户提供较一致的访问质量。

通常有三种负载均衡架构，分别是**链路负载均衡、集群负载均衡和操作系统负载均衡**。

- **链路负载均衡**是前面提到的通过DNS解析成不同的IP，然后用户根据这个IP来访问不同的目标服务器

  负载均衡是由DNS的解析来完成的，用户最终访问哪个web Server 是由DNS Server 来控制的，在这里就是由Global DNS Server 来动态解析域名服务。这种DNS解析的有点是用户会直接访问目标服务器，而不需要经过其他代理服务器，通常访问速度会更快。但是也有缺点，由于DNS在用户本地和Local DNS Server 都有缓存，一旦某台webServer 挂掉，就很难即使更新用户的域名解析结构。如果用户的域名没有即使更新，那么用户将无法访问这个域名，带来的后果非常严重。

- **集群负载均衡**是另外一种常见的负载均衡方式，它一般分为硬件负载均衡和软件负载均衡。硬件负载均衡一般使用一台专门的硬件设备来转发请求。

  硬件负载均衡的关键就是这台价格非常昂贵的设备，如F5，通常为了安全需要一主一备。它的有点很显然就是性能非常好，缺点就是非常贵，一般公司是用不起的，还有就是当访问量突然增大超出服务极限时，不能进行动态扩容

  软件负载均衡是使用最普遍的一种负载方式，它的特点是使用成本非常低，直接使用廉价的PC就可以搭建。缺点就是一般一次访问请求要经过多次代理服务器，会增加网络延时

- 操作系统负载均衡，利用操作系统级别的**软中断**或者**硬中断**来达到负载均衡，如可以设置多队列网卡等来实现。

这几种负载均衡不仅在CDN的集群中能使用，而且在Web服务或者分布式数据集群中同样也能使用，但是在这些地方后两种使用的要多一些。

### CDN动态加速

CDN的动态加速技术也是当前比较流行的一种优化技术，它的技术原理就是在CDN的DNS解析中通过动态的链路探测来寻找回源最好的一条路径，然后通过DNS的调度将所有请求调度到选定的这条路径上回源，从而加速用户访问效率。

由于CDN节点是遍布全国的，所以用户接入一个CDN节点后，可以选择一条从离用户最近的CDN节点到源站链路最好的路径让用户走。一个简单的原则就是在每个CDN节点上从源站下载一个一定大小的文件，看哪个链路的总耗时最短，这样可以构成一个链路列表，然后绑定到DNS解析上，更新到CDN的Local DNS。当然是否走这个链路并不一定根据耗时这个唯一条件，有时也要考虑网络成本。例如走某个节点虽然可以节约10ms，但是网络带宽的成本却增加了很多，还有其他网络链路的安全等因素也要综合考虑。


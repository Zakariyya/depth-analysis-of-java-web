# 深入分析Java I/O 的工作机制

[TOC]

I/O问题可以说是当今Web应用中所面临的主要问题之一，因为在当前这个海量数据时代，数据在网络中随处流动。在这个流动的过程中都设计I/O问题，可以说大部分web应用系统的瓶颈都是I/O瓶颈。

本章的目的是分析I/O的内在工作机制，你将了解到 Java 的I/O 类库的基本架构、硬盘I/O工作机制、网络I/O为重点介绍Java Socket的工作方式。了解NIO的工作方式，并了解同步和异步、阻塞与非阻塞的区别，一些常用I/O优化技巧

## Java的I/O类库的基本架构

I/O问题是任何编程语言都无法回避的问题，可以说I/O问题是整个人机交互的核心问题，因为I/O是机器获取和交换信息的主要渠道，在当今这个数据大爆炸时代，I/O问题尤其突出，很容易成为一个性能瓶颈。正因如此，Java在I/O上也一直在做持续的优化，从1.4版开始就引入了NIO，提升了I/O 的性能。

Java的I/O操作类在包Java.io下，大概又将近80个类，这些类大概可以分成以下4组：

- 基于字节操作的I/O接口：InputStream 和 outputStream
- 基于字符操作的I/O接口：Writer和Reader
- 基于磁盘操作的I/O接口；File
- 基于网络操作的I/O接口：Socket

前两组主要是传输数据的数据格式，后两组主要是传输数据的方式，虽然Socket类并不在java.io包次啊，但是任然把它们划分在一起，因为个人认为I/O的核心问题要么是数据格式影响I/O操作，要么是传输方式影响I/O操作，也就是将什么样的数据写到什么地方的问题。I/O只是人与机器或者机器与机器交互的手段，除了他们能够完成这个交互功能外，我们关注的就是如何提高它的运行效率了，而数据格式和传输方式是影响效率最关键的因素。

### 基于字节的I/O操作接口

参考JDK的API说明文档，这里说明两点

- 一是操作数据的方式可以组合使用的

  > ~~~java
  > OutputStram out  = new BufferedOutputStream(new ObjectOutputStream(new FileOutputStream("fileName")));
  > ~~~

- 二是必须要指定流最终写到什么地方，要么是写到磁盘，要么是写到网络中，其实从类层次结构中可以发现，写网络实际上也是写文件，只不过写网络还有一步需要处理，就是让底层操作系统再将数据传送到其他地方而不是本地磁盘。

### 基于字符的I/O操作接口

不管是磁盘还是网络传输，最小的储存单元都是字节，而不是字符，所以I/O操作都是字节而不是字符，但是为什么有操作字符的I/O接口？这是因为再我们的程序中通常操作的数据都是字符形式的，为了操作方便当然要提供直接写字符的I/O接口，仅此而已。从字符到字节必须要经过编码转换，而这个编码有非常耗时，而且还会经常出现乱码问题，所以I/O的编码问题经常是让人头疼的问题

读字符的操作接口是 int read(char cbuf[], int off, int len)，返回读到的n个字节数，不管是Writer还是Reader类，它们都只定义了读取或写入的数据字符的方式，也就是怎么写或读，但是并没有规定数据要写到哪里，这些内容就是我们后面要讨论的基于磁盘和网络的工作机制。

### 字节与字符的转化接口

另外，数据持久化或网络传输都是以字节进行的，所以必须要有从字符到字节或从字节到字符的转化。

InputStreamReader类是从字节到字符转化的桥梁，从inputSream到Reader的过程要指定编码字符集，否则将采用操作系统默认的字符集，很可能会出现乱码问题。StreamDeconder正是完成从字节到字符的解码的实现类。也就是当你用如下的方式读取一个文件时：

~~~java
try{
  StringBuffer str = new StringBuffer();
  char[] buf = new char[1024];
  FileReader f= new FileReader("file");
  while(f.read(bug)>0){
      str.append(buf);
  }
 str.toString();
}catch(IOException e){
}
~~~

FileReader类就是按照上面的工作方式读取文件的，FileReader继承了InputStreamReader类，实际上是读取文件流，然后通过StreamDeconder解码成char，只不过这里的解码字符集是默认字符集

通过OutputStreamWriter类完成了从字符到字节的编码过程，有StreamEncoder完成编码过程。

##硬盘I/O工作机制

### 几种访问文件的方式

我们知道，读取和写入文件I/O操作都调用操作系统提供的接口，因为磁盘设备是由操作系统管理的，应用程序要访问的物理设备只能通过系统调用的方式来工作。读和写分别对应read()和write()两个系统调用。而只要是系统调用就可能存在内核空间地址和用户空间地址切换的问题，这是操作系统为了保护系统本身的运行安全，而将内核程序运行使用的内存空间和用户程序运行的内存空间进行隔离造成的。但是这样虽然保证了内核程序运行的安全性，但是也必然存在数据可能需要从内核空间向用户空间复制的问题。

吐过遇到非常耗时的操作，如磁盘I/O，数据从磁盘复制到内核空间，然后又从内核空间复制到用户空间，将会非常缓慢。这时操作系统为了加速I/O访问，再内核空间使用缓存机制，就是将从磁盘读取的文件按照一定的组织方式进行缓存，如果用户程序访问的是同一段磁盘地址的空间数据，那么操作系统将从内核缓存中直接去返回给用户程序，这样可以减少I/O的响应时间。

#### 标准访问文件的方式

标准访问文件的方式就是当应用程序调用read()接口时，操作系统检查再内核的告诉缓存中有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回，如果没有，则从磁盘中读取，然后缓存再操作系统的缓存中。

写入的方式是，用户的应用程序调用write()接口将数据从用户地址空间复制到内核地址空间的缓存中。这时对用户程序来说操作就已经完成，至于什么时候再写到磁盘中由操作系统决定，除非显示地调用了sync同步命令。

####直接I/O方式

所谓的直接I/O的方式就是应用程序直接访问磁盘数据，而不经过操作系统内核数据缓冲区，这样做的目的就是减少一次从内核缓冲区到用户程序缓存的数据复制。这种访问文件的方式通常是对数据的缓存管理由应用程序实现的数据库管理系统中。如再数据库管理系统中，系统明确地知道应该缓存哪些数据，应该失效哪些数据，还可以对一些热点数据做预加载，提前将热点数据加载到内存，可以加速数据的访问效率。在这些情况下，如果是由操作系统进行缓存，则很难做到，因为操作系统并不知道哪些是热点数据，哪些数据可能只会访问一次就不会再访问，操作系统只是简单地缓存最近一次从磁盘读取的数据。

但是直接I/O也有负面影响，如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘进行加载，这种直接加载会非常缓慢。通常直接I/O与异步I/O结合使用，会得到比较好的性能。

#### 同步访问文件的方式

111


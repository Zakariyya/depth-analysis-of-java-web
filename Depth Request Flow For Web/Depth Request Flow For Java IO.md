# 深入分析Java I/O 的工作机制

[TOC]

I/O问题可以说是当今Web应用中所面临的主要问题之一，因为在当前这个海量数据时代，数据在网络中随处流动。在这个流动的过程中都设计I/O问题，可以说大部分web应用系统的瓶颈都是I/O瓶颈。

本章的目的是分析I/O的内在工作机制，你将了解到 Java 的I/O 类库的基本架构、硬盘I/O工作机制、网络I/O为重点介绍Java Socket的工作方式。了解NIO的工作方式，并了解同步和异步、阻塞与非阻塞的区别，一些常用I/O优化技巧

## Java的I/O类库的基本架构

I/O问题是任何编程语言都无法回避的问题，可以说I/O问题是整个人机交互的核心问题，因为I/O是机器获取和交换信息的主要渠道，在当今这个数据大爆炸时代，I/O问题尤其突出，很容易成为一个性能瓶颈。正因如此，Java在I/O上也一直在做持续的优化，从1.4版开始就引入了NIO，提升了I/O 的性能。

Java的I/O操作类在包Java.io下，大概又将近80个类，这些类大概可以分成以下4组：

- 基于字节操作的I/O接口：InputStream 和 outputStream
- 基于字符操作的I/O接口：Writer和Reader
- 基于磁盘操作的I/O接口；File
- 基于网络操作的I/O接口：Socket

前两组主要是传输数据的数据格式，后两组主要是传输数据的方式，虽然Socket类并不在java.io包次啊，但是任然把它们划分在一起，因为个人认为I/O的核心问题要么是数据格式影响I/O操作，要么是传输方式影响I/O操作，也就是将什么样的数据写到什么地方的问题。I/O只是人与机器或者机器与机器交互的手段，除了他们能够完成这个交互功能外，我们关注的就是如何提高它的运行效率了，而数据格式和传输方式是影响效率最关键的因素。

### 基于字节的I/O操作接口

参考JDK的API说明文档，这里说明两点

- 一是操作数据的方式可以组合使用的

  > ~~~java
  > OutputStram out  = new BufferedOutputStream(new ObjectOutputStream(new FileOutputStream("fileName")));
  > ~~~

- 二是必须要指定流最终写到什么地方，要么是写到磁盘，要么是写到网络中，其实从类层次结构中可以发现，写网络实际上也是写文件，只不过写网络还有一步需要处理，就是让底层操作系统再将数据传送到其他地方而不是本地磁盘。

### 基于字符的I/O操作接口

不管是磁盘还是网络传输，最小的储存单元都是字节，而不是字符，所以I/O操作都是字节而不是字符，但是为什么有操作字符的I/O接口？这是因为再我们的程序中通常操作的数据都是字符形式的，为了操作方便当然要提供直接写字符的I/O接口，仅此而已。从字符到字节必须要经过编码转换，而这个编码有非常耗时，而且还会经常出现乱码问题，所以I/O的编码问题经常是让人头疼的问题

读字符的操作接口是 int read(char cbuf[], int off, int len)，返回读到的n个字节数，不管是Writer还是Reader类，它们都只定义了读取或写入的数据字符的方式，也就是怎么写或读，但是并没有规定数据要写到哪里，这些内容就是我们后面要讨论的基于磁盘和网络的工作机制。

### 字节与字符的转化接口

另外，数据持久化或网络传输都是以字节进行的，所以必须要有从字符到字节或从字节到字符的转化。

InputStreamReader类是从字节到字符转化的桥梁，从inputSream到Reader的过程要指定编码字符集，否则将采用操作系统默认的字符集，很可能会出现乱码问题。StreamDeconder正是完成从字节到字符的解码的实现类。也就是当你用如下的方式读取一个文件时：

~~~java
try{
  StringBuffer str = new StringBuffer();
  char[] buf = new char[1024];
  FileReader f= new FileReader("file");
  while(f.read(bug)>0){
      str.append(buf);
  }
 str.toString();
}catch(IOException e){
}
~~~

FileReader类就是按照上面的工作方式读取文件的，FileReader继承了InputStreamReader类，实际上是读取文件流，然后通过StreamDeconder解码成char，只不过这里的解码字符集是默认字符集

通过OutputStreamWriter类完成了从字符到字节的编码过程，有StreamEncoder完成编码过程。

##硬盘I/O工作机制

### 几种访问文件的方式

我们知道，读取和写入文件I/O操作都调用操作系统提供的接口，因为磁盘设备是由操作系统管理的，应用程序要访问的物理设备只能通过系统调用的方式来工作。读和写分别对应read()和write()两个系统调用。而只要是系统调用就可能存在内核空间地址和用户空间地址切换的问题，这是操作系统为了保护系统本身的运行安全，而将内核程序运行使用的内存空间和用户程序运行的内存空间进行隔离造成的。但是这样虽然保证了内核程序运行的安全性，但是也必然存在数据可能需要从内核空间向用户空间复制的问题。

吐过遇到非常耗时的操作，如磁盘I/O，数据从磁盘复制到内核空间，然后又从内核空间复制到用户空间，将会非常缓慢。这时操作系统为了加速I/O访问，再内核空间使用缓存机制，就是将从磁盘读取的文件按照一定的组织方式进行缓存，如果用户程序访问的是同一段磁盘地址的空间数据，那么操作系统将从内核缓存中直接去返回给用户程序，这样可以减少I/O的响应时间。

#### 标准访问文件的方式

标准访问文件的方式就是当应用程序调用read()接口时，操作系统检查再内核的告诉缓存中有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回，如果没有，则从磁盘中读取，然后缓存再操作系统的缓存中。

写入的方式是，用户的应用程序调用write()接口将数据从用户地址空间复制到内核地址空间的缓存中。这时对用户程序来说操作就已经完成，至于什么时候再写到磁盘中由操作系统决定，除非显示地调用了sync同步命令。

####直接I/O方式

所谓的直接I/O的方式就是应用程序直接访问磁盘数据，而不经过操作系统内核数据缓冲区，这样做的目的就是减少一次从内核缓冲区到用户程序缓存的数据复制。这种访问文件的方式通常是对数据的缓存管理由应用程序实现的数据库管理系统中。如再数据库管理系统中，系统明确地知道应该缓存哪些数据，应该失效哪些数据，还可以对一些热点数据做预加载，提前将热点数据加载到内存，可以加速数据的访问效率。在这些情况下，如果是由操作系统进行缓存，则很难做到，因为操作系统并不知道哪些是热点数据，哪些数据可能只会访问一次就不会再访问，操作系统只是简单地缓存最近一次从磁盘读取的数据。

但是直接I/O也有负面影响，如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘进行加载，这种直接加载会非常缓慢。通常直接I/O与异步I/O结合使用，会得到比较好的性能。

#### 同步访问文件的方式

同步访问文件的方式比较容易理解，就是数据的读取和写入都是同步操作的，它与标准访问文件的方式不同的是，只有当数据被成功写到磁盘时才返回给应用程序成功的标志。

这种访问文件的方式性能比较差，只有在一些对数据安全性要求比较高的场景中才会使用，而且通常这种操作方式的硬件都是定制的。

#### 异步访问文件的方式

异步访问文件的方式就是当访问数据的线程发出请求之后，线程会接着去处理其他事情，而不是阻塞等待，当请求的数据返回后继续处理下面的操作。这种访问文件的方式可以明显地提高应用程序的效率，但是不会改变访问文件的效率。

#### 内存映射的方式

内存映射的方式是指操作系统将内存中的某一块区域与磁盘中的文件关联起来，当要访问内存中的一段数据时，转换为访问文件的某一段数据。这种方式的目的同样是减少数据从内核空间缓存到用户空间的数据复制操作，因为这两个空间的数据是共享的。

### Java访问磁盘文件

前面介绍了基本的java I/O的接口，这些接口主要定义了如何操作数据，并介绍了操作两种数据结构的字节和字符的方式。还有一个关键问题就是数据写到何处，其中一个主要方式就是将数据持久化到物理磁盘，下面将介绍如何将数据持久化到物理磁盘。

我们知道，数据在磁盘中唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也就是操作系统和磁盘驱动器交互的最小单元。值得注意的是，在java中通过File并不代表一个真实存在的文件对象，当你指定一个路径描述符合时，它就会返回一个代表这个路径的虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这么设计？

因为在大多数情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。例如，在我们的手机里通常存了几百个朋友的电话号码，但是我们关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，至于这个号码到底能不能打通，我们并不会时时刻刻都去检查，而只是在真正要给它打电话时才会看这个电话号码能不能用，也就是说使用这个电话记录要比打这个电话的次数多很多。

何时会真正检查一个文件存不存在在？就是在真正要读取这个文件时，例如，FileInputStream 类都是操作一个文件的接口，注意到在创建一个FileInputStream对象时会创建一个FileDecriptor对象，其实这个对象就是真正代表一个存在的文件对象的描述。当我们在操作一个文件对象时可以通过getFD()方法获取真正操作的底层操作系统相关联的文件描述。例如，可以调用FileDesriptor.sync() 方法将操作系统缓存中的数据强制刷新到物理磁盘中。

当传入一个文件路径时，将会根据这个路径创建一个File对象来标识这个文件，然后根据这个File对象创建真正读取文件的操作对象，这时将会真正创建一个关联真实存在的磁盘文件的文件描述符FileDecriptor，通过这个对象可以直接控制这个磁盘文件。由于我们需要读取的是字符格式，所以需要StreamDecoder类将byte解码为char格式。至于如何从磁盘驱动器上读取一段数据，操作系统会帮我们完成。至于操作系统是如何将数据持久化到磁盘及如何建立数据结构的，需要根据当前操作系统使用何种文件系统来回答。

### Java序列化技术

java序列化就是将一个对象转化成一串二进制表示的字节数组，通过保存或转移这些字节数据来达到持久化的目的。需要持久化，对象必须继承 java.io.Serializable 接口。反序列化则是相反的过程，将这个字节数组再重新构造成对象。我们知道反序列化时，必须有原始类作为模板，才能将对象还原，从这个过程我们可以猜测，序列化的数据并不是像class文件那样保存类的完整的结构信息。那么序列化的数据到底都含有哪些信息呢？

虽然java的序列化能够保证对象状态的持久保存，但是遇到一些对象结构复杂的情况还是比较难处理的，下面是对一下复杂的对象情况的总结：

- 当父类继承Serializable接口时，所有子类都可以被序列化
- 子类实现了Serializable接口，父类没有，父类中的属性不能序列化（不报错，数据会丢失），但是在子类中属性仍能正确序列化。
- 如果序列化的属性是对象，则这个对象也必须实现Serializable接口，否则会报错。
- 在反序列化时，如果对象的属性有修改或删除，则修改的部分属性会丢失，但不会报错。
- 在反序列化时，如果 serialVersionUID被修改，则反序列化时会失败。

在纯java环境下，java序列化能够很好的工作，但是在多语言环境下，使用java序列化存储后，很难用其他语言还原出结果。在这种情况下，还是要尽量存储通用的数据结构，如json或者XML结构数据，当前也有比较好的序列化工具，如google的protobuf等。

## 网络I/O工作机制

数据从一台主机发送到网络中的另一台主机需要经过很多步骤。首先需要有相互沟通的意向。其次要有能够沟通的物理渠道（物理链路）：是通过电话，还是直接面对面交流。

再次，双方见面时语言要能够交流，而且双方说话的步调要一致，明白什么时候该自己说话，什么时候该对方说话（通信协议）。本节将重点介绍通信协议和如何完成数据传输。

### TCP状态转化

在讨论如何进行Socket通信之前，我们先看看如何建立和关闭一个TCP连接，TCP连接的状态转换

![](http://ow9e5n0xh.bkt.clouddn.com/544465b00200001s.png)

1. CLOSEED：起始点，在超时或者连接关闭时进入此状态
2. LISTTEN：Server端在等待连接时的状态，Server端为此要调用Socket、bind、listen函数，就能进入此状态。这称为应用程序被动打开（等待客户端来连接）。
3. SYN-SENT：客户端发起连接，发送SYN给服务器端。如果服务器端不能连接，则直接进入CLOSED状态。
4. SYN-RCVD：与3对应，服务器端接受客户端的SYN请求，服务器端由LISTEN状态进入SYN-RCVD状态。同时服务器端要回应一个ACK，发送一个SYN给客户端；另外一种情况是，客户端在发起SYN的同时接收到服务器端的SYN请求，客户端会由SYN-SENT转换到SYN-RCVD状态。
5. ESTABLISHED：服务器端和客户端在完成3次握手后进入状态，说明已经可以开始传输数据了。
6. FIN-WAIT-1：主动关闭的一方，由状态5进入此状态。具体动作是发送FIN给对方。
7. FIN-WAIT-2：主动关闭的一方，接收到对方的FIN ACK，进入此状态。由此不能再接收对方的数据，但是能够向对方发送数据。
8. CLOSE-WAIT：接收到FIN以后，被动关闭的一方进入次状态。具体动作是正在接收到FIN的同时发送ACK。
9. LAST-ACK：被动关闭的一方，发起关闭请求，由状态8进入此状态。具体动作是发送FIN给对方，同时在接收到ACK时进入CLOSED状态。
10. CLOSEING：两边同时发起关闭请求时，会由FIN-WAIT-1进入此状态。具体动作是接收到FIN请求，同时相应一个ACK。
11. TIME-WAIT：这个状态比较复杂，也是我们最常见的一个连接状态，由3个状态可以转化为此状态

- 由FIN-WAIT-2转换到TIME-WAIT，具体情况是：在双方不同时发起FIN的情况下，主动关闭的一方在完成自身发起的关闭请求后，接收到被动关闭一方的FIN后进入的状态。
- 由CLOSING转换到TIME-WAIT，具体情况是：在双方同时发起关闭，都做了发起FIN的请求，同时接收到FIN并做了ACK的情况下，这时就由CLOSEING状态进入TIME-WAIT状态
- 由FIN-WAIT-1：这个状态比较复杂，也是我们最常见的一个连接状态